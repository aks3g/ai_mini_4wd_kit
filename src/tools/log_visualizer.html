<HTML>
<HEAD>
<meta charset="UTF-8">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<style type="text/css">
<!--
  html {
    max-width: 600pt;
    margin: 0 auto;
    background: khaki; /* Fills the page */
  }
  .buttons {
    width: 280pt;
    display: inline-block;
  }
  .map_range {
    width: 99%;
    display: inline-block;
  }
  a {
    text-decoration: none;
    color: black;
  }
  a:hover {
    color: khaki;
    background: darkorange;
  }
  .header_menu {
    background-color: gold;
    position: fixed;
    top:  0pt;
    left: 0;
    width: 100%;
    text-align: center;
  }
  .footer_menu {
    background-color: gold;
    position: fixed;
    bottom:  0pt;
    left: 0;
    width: 100%;
    height: 30pt;
  }
  .wrapper {
    padding-bottom: 40pt;
    box-sizing: border-box;
  }
  .dash_board {
    display: inline-block;
    width: 500px;
    text-align: left;
  }
  .sub_section {
    margin-top: 10pt;
    background-color: gold;
    width: 100%;
    font-weight: bold;
  }
  .menu_title {
    padding-top: 10pt;
    color: white;
    text-align: center;
    font-weight: bold;
    font-size: xx-large;
  }
  .logo_outline {
    text-shadow: 2px 2px 0px black,
      -2px  2px 0px black,
       2px -2px 0px black,
      -2px -2px 0px black;
  }

  .menu_copy {
    padding-top: 10pt;
    color: black;
    text-align: center;
  }
  .top {
    margin-top: 60pt;
  }

  .control_btn{
    margin-top: 2pt;
    margin-bottom: 2pt;
    width: 100pt;
    text-align: center;

    display: inline-block;
    padding: 0.5em 1em;
    text-decoration: none;
    background: gold;
    color: black;
    border-bottom: solid 4px darkgoldenrod;
    border-radius: 3px;

    float: center;
  }
  .control_btn:active {
    margin-top: 2pt;
    margin-bottom: 5pt;
    width: 100pt;
    text-align: center;

    -ms-transform: translateY(4px);
    -webkit-transform: translateY(4px);
    transform: translateY(4px);/*下に動く*/
    box-shadow: 0px 0px 1px rgba(0, 0, 0, 0.2);/*影を小さく*/
    border-bottom: none;
  }

  .wheel_select {
    margin-top: 10pt;
    margin-bottom: 10pt;
  }

  .check_box_span {
    width : 190pt;
    display: inline-block;
  }

  .check_box {
  }

  .map_canvas {
  }

  .canvas_graph{
    overflow-x:scroll;
  }

  .map_array{
    width:100%;
  }

  /* TAB表示に対応するためのあれこれ */
  .tab_labels{
    width:100%;
    font-size:0;
    margin:0 3px;
  }
  /* Tabに使うRadioButtonは不可視にする */
  input[type="radio"].for_tabs {
    display:none;
  }

  .tab_labels label{
    width:150px;
    margin:0 3px;
    display:inline-block;
    padding:10px 0;
    color:#999;
    background:darkkhaki;
    text-align:center;
    font-size:15px;
    cursor:pointer;
    transition:ease 0.2s opacity;
  }
  .tab_labels label:hover{
    opacity:0.5;
  }
  .tab_contents{
    background:beige;
  }
  .tab_content{
    width:100%;
    padding:1px 0;
    display:none;
  }
 
  #tab1:checked ~ .tab_labels .tab1_label{background:beige; color:#000;}
  #tab1:checked ~ .tab_contents #panel1{display:block;}
  #tab2:checked ~ .tab_labels .tab2_label{background:beige; color:#000;}
  #tab2:checked ~ .tab_contents #panel2{display:block;}
  #tab3:checked ~ .tab_labels .tab3_label{background:beige; color:#000;}
  #tab3:checked ~ .tab_contents #panel3{display:block;}
  #tab4:checked ~ .tab_labels .tab4_label{background:beige; color:#000;}
  #tab4:checked ~ .tab_contents #panel4{display:block;}
  #tab5:checked ~ .tab_labels .tab5_label{background:beige; color:#000;}
  #tab5:checked ~ .tab_contents #panel5{display:block;}

-->
</style>
<title> AI mini4wd Kit Log Visualizer </title>

<script language="javascript" type="text/javascript">
window.onload = function() {
  var canvas = document.getElementById("canvas_graph_raw");
  canvas.addEventListener('click', canvasOnClick, false);
}

//J Re-size時には描画をやり直す
window.onresize = function () {
}

//J Canvasクリック時の挙動を入れる（TODO）
function canvasOnClick(evt)
{
  //J Canvas上の点を求める
  var rect = evt.target.getBoundingClientRect();
  x = evt.clientX - rect.left;
  y = evt.clientY - rect.top;

  return;
}


/*-------------------------------------------------------------------------------------------------
 * 各種変数/定数定義
 */
//J TODO読み込むセンサデータの情報を決め打ちにする（将来的に柔軟にやっていきたい）
var IDX_AX    = 0;
var IDX_AY    = 1;
var IDX_AZ    = 2
var IDX_PITCH = 3;
var IDX_ROLL  = 4;
var IDX_YAW   = 5;
var IDX_RPM   = 6;
var IDX_VBAT  = 7;
var IDX_IMOT  = 8;


var SensorData = [];
var ResampledSensorData = [];
var TestData = [[], [], [], [], [], [], [], [], []];
var StateSpaceVec = [];
var ThresholdOfCurve = [];

var TracingContext = {
  xArr: [],
  yArr: [],
  lapArr: [],
}

var GraphTypeLine = 0;
var GraphTypeBar  = 1;

var SensorName = ["Accel-X", "Accel-Y", "Accel-Z", "Pitch", "Roll", "Yaw", "rpm", "V-BATT", "I-MOT"];
var SensorUnit = ["mG", "mG", "mG", "mdegree/sec", "mdegree/sec", "mdegree/sec", "rpm", "mV", "mA"];
var ResampledSensorUnit = ["mG", "mG", "mG", "mdegree", "mdegree", "mdegree", "rpm", "mV", "mA"];
var LineColors = ["maroon",    "darkblue",   "darkgreen",  "indigo",    "crimson",   "darkcyan" ]
var LineShadow = ["indianred", "dodgerblue", "aquamarine", "slateblue", "lightpink", "turquoise"]


var Jcjc_CenterRadius = 540;
var Jcjc_OuterRadius  = Jcjc_CenterRadius + 115;
var Jcjc_InnerRadius  = Jcjc_CenterRadius - 115;

//J 状態空間のベクトルを作る時に使う構造体もどき。死にたい
StateInfo = function(x, y, lap, feature) {
  this.x = x;
  this.y = y;
  this.lap = lap;
  this.feature = feature;
}

RectSize = function(w, h) {
  this.w = w;
  this.h = h;
}

Position = function(x, y) {
  this.x = x;
  this.y = y;
}

//J 3ラップ分の色情報とハイライト時の色情報
var FEATURE_UPDOWN = 1;
var FEATURE_OUT_LEFT = 2;
var FEATURE_CENTER_LEFT = 3;
var FEATURE_IN_LEFT = 4;
var FEATURE_OUT_RIGHT = 5;
var FEATURE_CENTER_RIGHT = 6;
var FEATURE_IN_RIGHT = 7;
var FEATURE_STRAIGHT = 8

var FeatureColorTable = ["#000000", "#ff0000", "#191970", "#0000cd", "#00bfff", "#2f4f4f", "#228b22", "#7fffd4", "#000000"]

var UNIT_mm = 100;


var DEBUG_string = ""

//J 自己位置推定系の変数
var SelfPositionEstimater = {
  milage_mm : 0,
  milage_index : 0,
  unit_mm : UNIT_mm,
//weight: 0.0005,
  weight: 0.001,

  existance: [],
  featureCount: [],

  //J Initialize
  initialize: function() {
    //J 移動距離を初期化
    this.milage_mm = 0.0;
    this.milage_index = 0;

    //J 存在確率分布の初期値を入れる
    this.existance = new Array(StateSpaceVec.length);
    this.existance.fill(0); //スタート地点に集める
    var lap = 0;
    this.existance[0] = 1.0/3.0;
    for (var i=1 ; i<StateSpaceVec.length ; ++i) {
      if (StateSpaceVec[i].lap != lap) {
        lap = StateSpaceVec[i].lap;
        this.existance[i] = 1.0/3.0;
      }
    }
    this.existance.fill(1.0/StateSpaceVec.length); //一様分布でいんだろうか…。


    //J 特徴量の個数だけ先に求めておく
    this.featureCount = new Array(9); //TODO
    this.featureCount.fill(0);

    for (var i=0 ; i<StateSpaceVec.length ; ++i) {
      this.featureCount[StateSpaceVec[i].feature]++;
    }
    console.log(this.featureCount);
  },

  //J 存在確率分布を返す
  getExistanceArr: function() {
    var slicePos = (this.existance.length-1) - Math.round(this.milage_mm/this.unit_mm) % this.existance.length;
　　if (slicePos < 1) {
      return this.existance;
    } else {
      return (this.existance.slice(slicePos)).concat(this.existance.slice(0, slicePos-1))
    }
  },
  //J 位置Indexにマシンがいる確率を取得
  getExistance: function(index) {return this.existance[(this.existance.length + index - Math.round(this.milage_mm/this.unit_mm)) % this.existance.length]},
  //J 位置Indexにマシンがいる確率を設定
  setExistance: function(index, val) {this.existance[(this.existance.length + index - Math.round(this.milage_mm/this.unit_mm)) % this.existance.length] = val},
  //J 移動距離、移動中の場所の特徴量から、存在確率をアップデートする
  estimate: function(delta_mm, feature) {
    this.milage_mm += delta_mm;

    if (this.featureCount[feature] == 0) {
      return -1;
    }

    var max = 0;
    var max_index = -1;
    var weighted_existance = this.weight / this.featureCount[feature];
    for (var i=0 ; i<this.existance.length ; ++i) {
      var prob = this.getExistance(i) * (1-this.weight);
      if (StateSpaceVec[i].feature == feature) {
        prob += weighted_existance;
      }
      this.setExistance(i, prob);

      if (prob > max) {
        max = prob;
        max_index = i;
      }
    }

    return max_index;
  }
}



/*-------------------------------------------------------------------------------------------------
 * データ解析関係処理
 */
//
// センサデータの文字列を解析して配列に入れる
//
function loadAndParseSensorFile(file)
{
  var reader = new FileReader();

  //J ファイルの中身を読み込む
  reader.onload = function (evt) {
    var raw = reader.result;
    SensorData = [[],[],[],[],[],[],[],[],[],[]] //J 内容を破棄する

    //J 1行に区切って処理する
    var lines = raw.split(/\r\n|\r|\n/);
    lines.forEach( function (line) {
      //J Tab区切りの数字列なのでこれを処理する
      var values = line.split(/\t/)
      if (values.length >= 10) { //J TODOレコード数を可変にしていきたい気持ちはある
        SensorData[IDX_AX].push(Number(values[IDX_AX+1]));
        SensorData[IDX_AY].push(Number(values[IDX_AY+1]));
        SensorData[IDX_AZ].push(Number(values[IDX_AZ+1]));
        SensorData[IDX_PITCH].push(Number(values[IDX_PITCH+1]));
        SensorData[IDX_ROLL].push(Number(values[IDX_ROLL+1]));
        SensorData[IDX_YAW].push(Number(values[IDX_YAW+1]));
        SensorData[IDX_RPM].push(Number(values[IDX_RPM+1]));
        SensorData[IDX_VBAT].push(Number(values[IDX_VBAT+1]));
        SensorData[IDX_IMOT].push(Number(values[IDX_IMOT+1]));
      }
    });

    //J 描画側にデータを渡す
    drawRawDataGraph("canvas_graph_raw", SensorData, 52*5, SensorName, SensorUnit);
    estimateVelocityAndOdometory(SensorData);

    ResampledSensorData = resampling(SensorData, UNIT_mm);
    drawResampledDataGraph("canvas_graph_resampling", ResampledSensorData, 20, SensorName, ResampledSensorUnit);

    //J 特徴量ヒストグラムと内周、中央周、外周を判断するための閾値を求める
    distribution = createFeatureValueHistgram(ResampledSensorData,UNIT_mm, -800, 800, 10);
    ThresholdOfCurve = decideThresholdOfFeatures(distribution, 10);
    drawFeatureDistributionGraph("canvas_graph_feature", distribution, 0, 0, "Feature Value Distribution", -800, 800, 1, ThresholdOfCurve);

    //J XY座標でコースをプロットする
    estimateMachinePosition(SensorData, {left:1.0, right:1.0});
    drawEstimatedMachinePosition(document.getElementById("canvas_graph_xy_plot"), TracingContext.xArr, TracingContext.yArr, TracingContext.lapArr);

    //J 3周分のデータを利用して、状態空間を作り出す
    StateSpaceVec = createStateSpaceVector(SensorData, UNIT_mm, {left:1.0, right:1.0}, ThresholdOfCurve);
    dumpStateSpaceVector(StateSpaceVec);
    drawStateSpaceVector("canvas_graph_estimate_position", StateSpaceVec, -1);
  }

  reader.readAsText(file);
}

//
// センサデータの文字列を解析して配列として返す
//
function loadAndParseSensorFileForTest(file)
{
  var reader = new FileReader();

  //J ファイルの中身を読み込む
  reader.onload = function (evt) {
    var raw = reader.result;
    TestData = [[],[],[],[],[],[],[],[],[],[]] //J 内容を破棄する

    //J 1行に区切って処理する
    var lines = raw.split(/\r\n|\r|\n/);
    lines.forEach( function (line) {
      //J Tab区切りの数字列なのでこれを処理する
      var values = line.split(/\t/)
      if (values.length >= 10) { //J TODOレコード数を可変にしていきたい気持ちはある
        TestData[IDX_AX].push(Number(values[IDX_AX+1]));
        TestData[IDX_AY].push(Number(values[IDX_AY+1]));
        TestData[IDX_AZ].push(Number(values[IDX_AZ+1]));
        TestData[IDX_PITCH].push(Number(values[IDX_PITCH+1]));
        TestData[IDX_ROLL].push(Number(values[IDX_ROLL+1]));
        TestData[IDX_YAW].push(Number(values[IDX_YAW+1]));
        TestData[IDX_RPM].push(Number(values[IDX_RPM+1]));
        TestData[IDX_VBAT].push(Number(values[IDX_VBAT+1]));
        TestData[IDX_IMOT].push(Number(values[IDX_IMOT+1]));
      }
    });

    document.getElementById("map_range").min = 0;
    document.getElementById("map_range").max = TestData[0].length;

    SelfPositionEstimater.initialize();
  }

  reader.readAsText(file);
}


//
// 回転数、加速度から速度と移動量を割り出す
//
function estimateVelocityAndOdometory(data)
{
  var velocityArr = [];
  var velocityArrFromAccel = [];

  var odometryArr = [];
  var odometryArrFromAccel = [];

  var Interval = 1.0/52.0;
  var WheelSize = parseFloat(document.getElementById("wheel_size").value);
  if (WheelSize == NaN) {
    return;
  }

  var odometry = 0;
  var velocity = 0;
  //J タコメータベースの速度と距離
  for (var i=0 ; i<data[IDX_RPM].length ; ++i) {
    var delta_mm = WheelSize * Math.PI * (data[IDX_RPM][i] / 60.0) * Interval;
    velocity = (delta_mm / (1000.0 * 1000.0)) / (Interval / 3600.0);

    velocityArr.push(velocity)

    odometry += delta_mm;
    odometryArr.push(odometry);
  }

  //J 加速度センサベースの速度と距離
  var odometry = 0;
  var velocity = 0;
  for (var i=0 ; i<data[IDX_AY].length ; ++i) {
    odometry = 0.5 * (9.8 / 1000.0) * data[IDX_AY][i] * Interval * Interval + velocity * Interval + odometry;
    velocity = (9.8 / 1000.0) * data[IDX_AY][i] * Interval + velocity;

    velocityArrFromAccel.push(velocity * (3600.0 / 1000.0))   //J m/s -> km/h
    odometryArrFromAccel.push(odometry * 1000); //J m -> mm
  }

  //J 描画（この処理は再描画が必要ない　と思う）
  drawVelocityAndOdometryGraph(velocityArr, odometryArr, velocityArrFromAccel, odometryArrFromAccel);
}

//
// Canvas上にミニ四駆の位置を推定する
//
function estimateMachinePosition(data, coeff)
{
  if (data.length == 0) {
    return;
  }

  TracingContext.xArr = [];
  TracingContext.yArr = [];
  TracingContext.lapArr = [];

  var Interval = 1.0/52.0;
  var WheelSize = parseFloat(document.getElementById("wheel_size").value);
  if (WheelSize == NaN) {
    return;
  }

  //J タコメータの値とYaw軸の回転を見ながら位置をプロットする
  var direction = 0;
  var posX = 0;
  var posY = 0;
  var lap = 0;

  for (var i=0 ; i<data[IDX_RPM].length ; ++i) {
    var delta_mm = WheelSize * Math.PI * (data[IDX_RPM][i] / 60.0) * Interval;

    yaw_corrected = (data[IDX_YAW][i] < 0) ? (data[IDX_YAW][i] * coeff.right) : (data[IDX_YAW][i] * coeff.left)
    direction += getValidAngularVelocity_degree(yaw_corrected) * Interval; //mdegree/sec -> degree
    direction = round180(direction)
    if (posX < 0 && (posX + delta_mm * Math.cos(direction * Math.PI/180.0)) >= 0) {
      lap++;
      direction = 0;
    }
    posX += delta_mm * Math.cos(direction * Math.PI/180.0);
    posY += delta_mm * Math.sin(direction * Math.PI/180.0);

    TracingContext.xArr.push(posX);
    TracingContext.yArr.push(posY);
    TracingContext.lapArr.push(lap);
  }

  //J Lapの選択情報も一緒に出力する
  var selecter_html = "";
  for (var i=0 ; i<=lap ; ++i) {
    selecter_html += "<input type=\"checkbox\" id=\"lap" + i.toString() + "\" checked onChange=\"updateEstimatedMachinePosition()\">Lap "+ i.toString()
  }
  lap_sel = document.getElementById("lap_selecter").innerHTML = selecter_html;

}

//
// 閾値チェックをして、信用できる値だけ返す
//
function getValidAngularVelocity_degree(mdegree)
{
  if (Math.abs(mdegree) < 10000.0) {
    return 0.0;
  }
  else {
    return mdegree / 1000.0;
  }
}

//
// 特定のラップの先頭位置を探す
//
function searchHeadOfLap(lap, lapArr)
{
  for(var i=0 ; i<lapArr.length ; ++i) {
    if(lapArr[i] == lap) {
      return i;
    }
  }

  return NaN;
}

//
// 特定のラップの終了位置を探す
//
function searchTailOfLap(lap, lapArr)
{
  for(var i=lapArr.length-1 ; i>=0 ; --i) {
    if(lapArr[i] == lap) {
      return i;
    }
  }

  return NaN;
}

//
// 角度(degree)を、プラスマイナス180度に正規化する
//
function round180(direction)
{
  direction = direction % 360;
  if (direction < 0) {
    direction = direction + 360;
  }

  if (direction > 180) {
    direction = direction - 360;
  }

  return direction;
}


//
// unitで指定された距離ごとにセンサデータをリサンプリングする
//
function resampling(data, unit)
{
  var Interval = 1.0/52.0;
  var WheelSize = parseFloat(document.getElementById("wheel_size").value);
  if (WheelSize == NaN) {
    return;
  }

  var resampled = [[],[],[],[],[],[],[],[],[],[]];

  var ax = 0;
  var ay = 0;
  var az = 0;
  var pitch = 0;
  var roll = 0;
  var yaw = 0;
  var rpm = 0;
  var vbat = 0;
  var imot = 0;

  //J 全データをなめる
  var distance = 0;
  var index = 0;
  var cnt = 0;
  for (var i=0 ; i<data[0].length ; ++i) {
    var delta_mm = WheelSize * Math.PI * (data[IDX_RPM][i] / 60.0) * Interval;

    if ((delta_mm + distance) > index * unit) {
      //J 未処理の距離
      var fragment = (index * unit) - distance;
      var remaining_delta = delta_mm;
      //J 1回のイテレーションでUnit以上進むケースを考慮
      do {
        cnt++;
        var remaining_rate = (fragment / delta_mm);

        ax    += data[IDX_AX][i];
        ay    += data[IDX_AY][i];
        az    += data[IDX_AZ][i];
        pitch += data[IDX_PITCH][i] * remaining_rate * 1/52;
        roll  += data[IDX_ROLL][i]  * remaining_rate * 1/52;
        yaw   += data[IDX_YAW][i]   * remaining_rate * 1/52;
        rpm   += data[IDX_RPM][i];
        vbat  += data[IDX_VBAT][i];
        imot  += data[IDX_IMOT][i];

        resampled[IDX_AX].push(ax/cnt)
        resampled[IDX_AY].push(ay/cnt)
        resampled[IDX_AZ].push(az/cnt)
        resampled[IDX_PITCH].push(pitch)
        resampled[IDX_ROLL].push(roll)
        resampled[IDX_YAW].push(yaw)
        resampled[IDX_RPM].push(rpm/cnt)
        resampled[IDX_VBAT].push(vbat/cnt)
        resampled[IDX_IMOT].push(imot/cnt)

        ax    = 0;
        ay    = 0;
        az    = 0;
        pitch = 0;
        roll  = 0;
        yaw   = 0;
        rpm   = 0;
        vbat  = 0;
        imot  = 0;

        index++;
        cnt = 0;
	remaining_delta -= fragment;

        fragment = unit;
      } while (remaining_delta > unit)

      var fragment_rate = (remaining_delta) / delta_mm;
      ax    = data[IDX_AX][i];
      ay    = data[IDX_AY][i];
      az    = data[IDX_AZ][i];
      pitch = data[IDX_PITCH][i] * fragment_rate * 1/52;
      roll  = data[IDX_ROLL][i]  * fragment_rate * 1/52;
      yaw   = data[IDX_YAW][i]   * fragment_rate * 1/52;
      rpm   = data[IDX_RPM][i];
      vbat  = data[IDX_VBAT][i];
      imot  = data[IDX_IMOT][i];
      cnt++;
    }
    else {
      ax    += data[IDX_AX][i];
      ay    += data[IDX_AY][i];
      az    += data[IDX_AZ][i];
      pitch += data[IDX_PITCH][i] * 1/52;
      roll  += data[IDX_ROLL][i] * 1/52;
      yaw   += data[IDX_YAW][i] * 1/52;
      rpm   += data[IDX_RPM][i];
      vbat  += data[IDX_VBAT][i];
      imot  += data[IDX_IMOT][i];
      cnt++;
    }
    distance = delta_mm + distance;
  }

  return resampled;
}

//
// 移動距離とYaw軸、Pitch軸の角度変化から特徴量を出します
//
function featureValue(delta_mm, yaw_deg, pitch_deg, threshold)
{
  var feature = 0;
  var radius = 0

  if (Math.abs(yaw_deg) != 0) {
    radius = (delta_mm / (yaw_deg / 360)) / (2 * Math.PI);
  }

  if (pitch_deg > 3.0) {
    feature = FEATURE_UPDOWN;
  }
  else if (threshold.center_to_outer_left <= radius && radius < 800) {
    feature = FEATURE_OUT_LEFT;
  }
  else if (threshold.inter_to_center_left <= radius && radius < threshold.center_to_outer_left) {
    feature = FEATURE_CENTER_LEFT;
  }
  else if (300 <= radius && radius < threshold.inter_to_center_left) {
    feature = FEATURE_IN_LEFT;
  }
  else if (threshold.inter_to_center_right <= radius && radius < -300) {
    feature = FEATURE_IN_RIGHT;
  }
  else if (threshold.center_to_outer_right <= radius && radius < threshold.inter_to_center_right) {
    feature = FEATURE_CENTER_RIGHT;
  }
  else if (-800 <= radius && radius < threshold.center_to_outer_right) {
    feature = FEATURE_OUT_RIGHT;
  }
  else {
    feature = FEATURE_STRAIGHT;
  }

  return feature;
}


//
// 特定コースにおける状態空間を作ります
//
function createStateSpaceVector(data, unit, coeff, threshold)
{
  var Interval = 1.0/52.0;
  var WheelSize = parseFloat(document.getElementById("wheel_size").value);
  if (WheelSize == NaN) {
    return;
  }

  var stateSpaceVec = []

  var posX = 0;
  var posY = 0;
  var lap  = 0;

  var distance = 0;
  var direction = 0;

  var yaw = 0;
  var pitch = 0;
  var rpm = 0;

  var index = 0;
  var cnt = 0;
  for (var i=0 ; i<data[0].length ; ++i) {
    var delta_mm = WheelSize * Math.PI * (data[IDX_RPM][i] / 60.0) * Interval;

    yaw_corrected = (data[IDX_YAW][i] < 0) ? (data[IDX_YAW][i] * coeff.right) : (data[IDX_YAW][i] * coeff.left)
    direction += getValidAngularVelocity_degree(yaw_corrected) * Interval; //mdegree/sec -> degree
    direction = round180(direction)
    if (posX < 0 && (posX + delta_mm * Math.cos(direction * Math.PI/180.0)) >= 0) {
      lap++;
      direction = 0;
      if (lap >= 3) {
        break;
      }
    }
    posX += delta_mm * Math.cos(direction * Math.PI/180.0);
    posY += delta_mm * Math.sin(direction * Math.PI/180.0);

    //J 状態空間単位毎にパッキング
    if ((delta_mm + distance) > index * unit) {
      var fragment = (index * unit) - distance;
      var remaining_delta = delta_mm;

      //J 1回のイテレーションでUnit以上進むケースを考慮
      do {
        cnt++;
        var remaining_rate = (fragment / delta_mm);

        yaw   += data[IDX_YAW][i] * remaining_rate * 1/52;
        pitch += data[IDX_PITCH][i] * remaining_rate * 1/52;
        rpm   += data[IDX_RPM][i];

        var feature = featureValue(unit, yaw / 1000.0, pitch / 1000.0, threshold);

        //J 状態空間の1点としてPush
        stateSpaceVec.push(new StateInfo(posX, posY, lap, feature));

        pitch = 0;
        yaw   = 0;
        rpm   = 0;

        index++;
        cnt = 0;
	remaining_delta -= fragment;

        fragment = unit;
      } while (remaining_delta > unit)

      var fragment_rate = (remaining_delta) / delta_mm;
      yaw   = data[IDX_YAW][i] * fragment_rate * 1/52;
      pitch = data[IDX_PITCH][i] * fragment_rate * 1/52;
      rpm   = data[IDX_RPM][i];
      cnt++;
    }
    else {
      yaw   += data[IDX_YAW][i] * 1/52;
      pitch += data[IDX_PITCH][i] * 1/52;
      rpm   += data[IDX_RPM][i];
      cnt++;
    }
    distance = delta_mm + distance;
  }

  return stateSpaceVec;
}


//
// マシンの回転半径のヒストグラムを生成
//
function createFeatureValueHistgram(resampled_data, unit, min_range, max_range, step)
{
  var distribution = new Array((max_range-min_range)/step);
  distribution.fill(0);

  for (var i=0 ; i<resampled_data[0].length ; ++i) {
    var degree = resampled_data[IDX_YAW][i] / 1000.0;
    if (Math.abs(degree) < 1) {
      continue;
    }
    
    var radius = (unit / (degree / 360)) / (2 * Math.PI);

    var bin = Math.round((radius - min_range) / step);
    if (bin >= distribution.length) {
      bin = distribution.length-1;
    }
    else if (bin < 0) {
      bin = 0;
    }
    distribution[bin]++;
  }

  //J ３レーン分のピークがどこかに立つはずなのでこれを探す
  //J ピークの位置と理論値の比を求める


  return distribution;
}

//
// 配列の中で最小の値の位置を返します。探索が配列の中央から始まるので、最小の値が複数ある場合には中央に近い部分が選ばれます
//
function searchMinIndex(arr)
{
  var min = Math.min(...arr);

  var minIndex = -1;
  var i = 0;
  var center_of_arr = Math.round(arr.length/2);
  for (i=0 ; i<center_of_arr ; ++i) {
    if ((center_of_arr + i < arr.length) && (min == arr[center_of_arr + i])) {
      return center_of_arr + i;
    }
    if ((center_of_arr - i >= 0) && (min == arr[center_of_arr - i])) {
      return center_of_arr - i;
    }
  }

  return -1;
}

//
// マシン回転半径によるラップの切り分け用の閾値を返します
//
function decideThresholdOfFeatures(distribution, step)
{
  //J 左回りの場合の中央値の間で最小の値を採用する
  var bin_center = Math.round(distribution.length/2 + (Jcjc_CenterRadius / step));
  var bin_outer  = Math.round(distribution.length/2 + (Jcjc_OuterRadius / step));
  var bin_inner  = Math.round(distribution.length/2 + (Jcjc_InnerRadius / step));

  var sub_arr = distribution.slice(bin_inner, bin_center);
  var threshold_inter_to_center_left = searchMinIndex(sub_arr) + bin_inner;

  sub_arr = distribution.slice(bin_center, bin_outer);
  var threshold_center_to_outer_left = searchMinIndex(sub_arr) + bin_center;

  //J 右回りの場合の中央値の間で最小の値を採用する
  var bin_center = Math.round(distribution.length/2 - (Jcjc_CenterRadius / step));
  var bin_outer  = Math.round(distribution.length/2 - (Jcjc_OuterRadius / step));
  var bin_inner  = Math.round(distribution.length/2 - (Jcjc_InnerRadius / step));

  var sub_arr = distribution.slice(bin_center, bin_inner);
  var threshold_inter_to_center_right = searchMinIndex(sub_arr) + bin_center;

  sub_arr = distribution.slice(bin_outer, bin_center);
  var threshold_center_to_outer_right = searchMinIndex(sub_arr) + bin_outer;

  //このリテラルの形をここで定義して本当にいいんだろうか
  var threshold = {
    inter_to_center_left:  (threshold_inter_to_center_left - Math.round(distribution.length/2))* step,
    center_to_outer_left:  (threshold_center_to_outer_left - Math.round(distribution.length/2))* step,
    inter_to_center_right: (threshold_inter_to_center_right - Math.round(distribution.length/2))* step,
    center_to_outer_right: (threshold_center_to_outer_right - Math.round(distribution.length/2))* step,
  }

  console.log(threshold)

  return threshold;
}

//
// シミュレータのアップデート処理. 時間ごとの処理を行う
//
function updateSimulater(tick)
{
  var Interval = 1.0/52.0;
  var WheelSize = parseFloat(document.getElementById("wheel_size").value);
  if (WheelSize == NaN) {
    return;
  }

  var delta_mm = WheelSize * Math.PI * (TestData[IDX_RPM][tick] / 60.0) * Interval;
  var feature  = featureValue(delta_mm, TestData[IDX_YAW][tick]*Interval/1000.0, TestData[IDX_PITCH][tick]*Interval/1000.0, ThresholdOfCurve);

  var position = SelfPositionEstimater.estimate(delta_mm, feature);

  drawStateSpaceVector("canvas_graph_estimate_position", StateSpaceVec, position);
  drawExistanceGraph("canvas_graph_existance", SelfPositionEstimater.getExistanceArr());
}


/*-------------------------------------------------------------------------------------------------
 * グラフの描画処理
 */
//
// 折れ線グラフの罫線を描画
//
function _drawGraphRuledLine(ctx2d, x, y, w, h, sub_x, sub_y, min, max, label)
{
  var scale = h / (max - min);
  var y0 = y + scale * max;

  ctx2d.beginPath();

  ctx2d.lineWidth = 0.5;
  ctx2d.strokeRect(x, y, w, h);

  if (min < 0) {
    ctx2d.moveTo(x,   y0);
    ctx2d.lineTo(x+w, y0);
  }

  for (var i=sub_x + x ; i<w+x ; i += sub_x) {
    ctx2d.moveTo(i, y);
    ctx2d.lineTo(i, y+h);
  }
  ctx2d.stroke();
  ctx2d.lineWidth = 1.0;



  //J Rangeを出す
  ctx2d.textAlign="right";
  //J 暫定対策（恒久対策ってするんだろうか…）
  if (max >= 1) {
    ctx2d.strokeText(Math.round(max).toString(), x - 3, y + 10);
  }
  else {
    ctx2d.strokeText((Math.round(max*1000)/1000).toString(), x - 3, y + 10);
  }

  ctx2d.strokeText(Math.round(min).toString(), x - 10, y + h);
  if (min < 0) {
    ctx2d.strokeText("0", x - 10, y0);
  }
  ctx2d.textAlign="start";

  //J ラベルを出す
  ctx2d.save()
  {
    //J 中心軸を文字中心に変更する
    ctx2d.translate(20, y + h/2);
    ctx2d.rotate(-90 * Math.PI/180);
    ctx2d.textAlign="center";
    ctx2d.strokeText(label, 0, 0);
  }
  ctx2d.restore();
}


//
// 折れ線グラフ本体の描画
//
function _drawLineGraphBody(ctx2d, arr, x, y, w, h, min, max)
{
  var scale = h / (max - min);

  var y0 = y + scale * max;
  var x0 = x;

  ctx2d.strokeStyle="maroon";
  ctx2d.shadowBlur = 2;
  ctx2d.shadowColor = "indianred"
  ctx2d.beginPath();
  ctx2d.moveTo(x0, y0 - arr[0]*scale);

  var i=1;
  for (i=1 ; i<arr.length ; ++i) {
    ctx2d.lineTo(x0+i, y0 - arr[i]*scale);
  }
  ctx2d.stroke();
  ctx2d.strokeStyle="black";
  ctx2d.shadowBlur = 0;
}

//
// 折れ線グラフの描画
//
function _drawLineGraph(ctx2d, arr, x, y, w, h, sub_x, sub_y, min, max, label)
{
  _drawGraphRuledLine(ctx2d, x, y, w, h, sub_x, sub_y, min, max, label);
  _drawLineGraphBody(ctx2d, arr, x, y, w, h, min, max)
}


//
// 棒グラフの罫線を描画
//
function _drawBarGraphRuledLine(ctx2d, x, y, w, h, sub_x, sub_y, min_range, max_range,label)
{
  var margin_y = 100;

  ctx2d.strokeStyle = "black";
  ctx2d.beginPath()
  ctx2d.lineWidth = 1;
  ctx2d.strokeRect(x, y, w, h);

  ctx2d.textAlign="center";
  ctx2d.strokeText(label, x+w/2, y+h + margin_y*2/3);

  ctx2d.stroke();

  var x0 = w * min_range/(min_range + max_range);

  //J 軸
  ctx2d.beginPath()
  for (var i = min_range ; i<=max_range ; i+=sub_x * 100) {
    var posX = w * (i - min_range)/(max_range - min_range) + x;
    ctx2d.moveTo(posX, y);
    ctx2d.lineTo(posX, y + h);

    ctx2d.textAlign="center";
    ctx2d.strokeText(i.toString(), posX, y+h + margin_y/4);
  }
  ctx2d.stroke();
}

//
// 棒グラフ本体の描画
//
function _drawBarGraphBody(ctx2d, arr, x, y, w, h)
{
  var scale = h / Math.max(...arr);
  var bin_width = w / arr.length;

  ctx2d.fillStyle = "maroon";
  for (var i=0 ; i<arr.length ; ++i) {
    ctx2d.fillRect(x + i*bin_width - bin_width/2, y+h - scale*arr[i], bin_width, scale*arr[i]);
  }
}

//
// 棒グラフの描画
//
function _drawBarGraph(ctx2d, arr, x, y, w, h, sub_x, sub_y, min, max, label)
{
  _drawBarGraphRuledLine(ctx2d, x, y, w, h, sub_x, sub_y, min, max, label);
  _drawBarGraphBody(ctx2d, arr, x, y, w, h);
}

//
// グラフ描画の一番入り口になる関数
//
function _drawGraph(graph_type, ctx2d, arr, x, y, w, h, sub_x, sub_y, min, max, label)
{
  if (graph_type == GraphTypeLine) {
    _drawLineGraph(ctx2d, arr, x, y, w, h, sub_x, sub_y, min, max, label)
  }
  else if (graph_type == GraphTypeBar) {
    _drawBarGraph(ctx2d, arr, x, y, w, h, sub_x, sub_y, min, max, label)
  }
}

/*-------------------------------------------------------------------------------------------------
 * センサデータの可視化処理
 */
//
// センサデータを選択するCheck Boxのうち、チェックされているものの数を調べる
//
function checkValidSensorGraphNum(select_form)
{
  var num = 0;
  for (var i=0 ; i<select_form.sensors.length ; ++i) {
    if (select_form.sensors[i].checked) {
      num++;
    }
  }

  return num;
}

//
// 選択されているセンサデータのみグラフとして描画する
//
function drawSensorDataGraph(canvas_name, data, xaxis_sub_ruled_interval, sensor_name, sensor_unit, selecter)
{
  if (data == NaN || data.length == 0) {
    return;
  }

  var numGraph = checkValidSensorGraphNum(selecter);
  var canvas = document.getElementById(canvas_name);
  var ctx2d = canvas.getContext("2d");

  var height = 150;
  var width = data[0].length ;

  var margin_left   = 50;
  var margin_right  = 10;
  var margin_top    = 5;
  var margin_bottom = 5;

  //J widthはデータ数に依存、heightはデータ種別数に依存
  canvas.setAttribute("width",  (width +  margin_left + margin_right).toString(10));
  canvas.setAttribute("height", ((numGraph * height) + ((margin_top+margin_bottom) * numGraph)).toString(10));

  //J 下地は透明色にする
  ctx2d.fillStyle = "rgba(0, 0, 0, 0)";
  ctx2d.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);

  //J グラフがない場合はここで終わる
  if (numGraph == 0) {
    return;
  }

  var i;
  var j = 0;
  for (i=0 ; i<9 ; ++i) {
    if (selecter.sensors[i].checked) {
      label = sensor_name[i] + "[" + sensor_unit[i] + "]";
      _drawGraph(GraphTypeLine, ctx2d, data[i], margin_left, j*(height + margin_top + margin_bottom) + margin_top, width, height, xaxis_sub_ruled_interval, 0, Math.min(...data[i]), Math.max(...data[i]), label);
      j++;
    }
  }
}

//
// 再サンプリングされたセンサデータの描画
//
function drawResampledDataGraph(canvas_name, data, xaxis_sub_ruled_interval, sensor_name, sensor_unit)
{
  drawSensorDataGraph(canvas_name, data, xaxis_sub_ruled_interval, sensor_name, sensor_unit, document.resampled_data_select_form);
}

//
// 再サンプリングされたセンサデータの再描画
//
function updateResampledDataGraph()
{
  drawResampledDataGraph("canvas_graph_resampling", ResampledSensorData, 20, SensorName, ResampledSensorUnit);
}


//
// RAWセンサデータの描画
//
function drawRawDataGraph(canvas_name, data, xaxis_sub_ruled_interval, sensor_name, sensor_unit)
{
  drawSensorDataGraph(canvas_name, data, xaxis_sub_ruled_interval, sensor_name, sensor_unit, document.data_select_form);
}

//
// RAWセンサデータの再描画
//
function updateRawDataGraph()
{
  drawRawDataGraph("canvas_graph_raw", SensorData, 52*5, SensorName, SensorUnit);
}

//
// 回転数、加速度をソースとした移動距離と速度グラフの描画
//
function drawVelocityAndOdometryGraph(velocityArr, odometryArr, velocityArrFromAccel, odometryArrFromAccel)
{
  if (velocityArr.length == 0) {
    return;
  }

  var canvas = document.getElementById("canvas_graph_velocity");
  var ctx2d = canvas.getContext("2d");
  var graph_margin_y = 10;
  var graph_offset_x = 50
  var width = velocityArr.length;
  var height = 200;

  //J widthはデータ数に依存、heightはデータ種別数に依存
  canvas.setAttribute("width",  (width +  + graph_offset_x + 10).toString(10));
  canvas.setAttribute("height", (4 * height + graph_margin_y * 4).toString(10));

  //J 下地は透明色にする
  ctx2d.fillStyle = "rgba(0, 0, 0, 0)";
  ctx2d.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);


  //J タコメータベースの推定
  //J 速度グラフを表示
  var label = "Velocity[km/h]"
  _drawGraph(GraphTypeLine, ctx2d, velocityArr, graph_offset_x, 0*(height + graph_margin_y) + graph_margin_y/2, width, height, 52*5, 0, 0, Math.max(...velocityArr), label);

  //J 距離グラフを表示
  var label = "Odometry[mm]"
  _drawGraph(GraphTypeLine, ctx2d, odometryArr, graph_offset_x, 1*(height + graph_margin_y) + graph_margin_y/2, width, height, 52*5, 0, 0, Math.max(...odometryArr), label);


  //J 加速度センサベースの推定
  //J 速度グラフを表示
  var label = "Velocity[km/h] from accel"
  _drawGraph(GraphTypeLine, ctx2d, velocityArrFromAccel, graph_offset_x, 2*(height + graph_margin_y) + graph_margin_y/2, width, height, 52*5, 0, 0, Math.max(...velocityArrFromAccel), label);

  //J 距離グラフを表示
  var label = "Odometry[mm] from accel"
  _drawGraph(GraphTypeLine, ctx2d, odometryArrFromAccel, graph_offset_x, 3*(height + graph_margin_y) + graph_margin_y/2, width, height, 52*5, 0, 0, Math.max(...odometryArrFromAccel), label);
}

//
// 回転数、加速度をソースとした移動距離と速度グラフの再描画
//
function updateVelocityAndOdometryGraph()
{
  //J 再描画のためには推定からやり直す必要がある
  estimateVelocityAndOdometory(SensorData);
}

//
// ミニ四駆の位置をXYでプロットする
//
function drawEstimatedMachinePosition(canvas, xArr, yArr, lapArr)
{
  //J キャンパスのサイズを決定
  var x_range = (Math.max(...xArr) + (-1 * Math.min(...xArr))) * 1.05;
  var y_range = (Math.max(...yArr) + (-1 * Math.min(...yArr))) * 1.05;
  var scale =  document.getElementById("sensor_visualizer").clientWidth / x_range;

  canvas.setAttribute("width",  (x_range * scale).toString(10));
  canvas.setAttribute("height", (y_range * scale).toString(10));

  //J 原点を決定
  var x0 = - Math.min(...xArr) * 1.025;
  var y0 =   Math.max(...yArr) * 1.025;

  var ctx2d = canvas.getContext("2d");
  var lap = Math.max(...lapArr);
  //J XYのプロットを行う
  for (var i=0 ; i<=lap ; ++i) {
    head = searchHeadOfLap(i, lapArr);
    tail = searchTailOfLap(i, lapArr);
    if (head == NaN || tail == NaN) {
      break;
    }

    if (false == document.getElementById("lap"+i.toString()).checked) {
      continue;
    }

    //J 線の情報を更新
    ctx2d.strokeStyle = LineColors[i%6];
    ctx2d.shadowColor = LineColors[i%6];
    ctx2d.shadowBlur  = 5;

    ctx2d.beginPath();
    ctx2d.moveTo((x0 + xArr[head]) * scale, (y0 - yArr[head]) * scale);
    for (var j=head+1 ; j<=tail ; ++j) {
      var x = (x0 + xArr[j]) * scale;
      var y = (y0 - yArr[j]) * scale;
      ctx2d.lineTo(x, y);
    }
    ctx2d.stroke();

    ctx2d.strokeStyle="black";
    ctx2d.shadowBlur = 0;
  }

  //J 尺のリファレンスを置く
  var sizeOf500mm = scale * 500;
  ctx2d.beginPath();
  ctx2d.moveTo(x_range * scale - 20, y_range * scale - 20);
  ctx2d.lineTo(x_range * scale - 20 - sizeOf500mm, y_range * scale - 20);

  ctx2d.moveTo(x_range * scale - 20 - sizeOf500mm, y_range * scale - 10);
  ctx2d.lineTo(x_range * scale - 20 - sizeOf500mm, y_range * scale - 30);

  ctx2d.moveTo(x_range * scale - 20, y_range * scale - 10);
  ctx2d.lineTo(x_range * scale - 20, y_range * scale - 30);

  ctx2d.textAlign="center";
  ctx2d.strokeText("500mm", x_range * scale - 20 - sizeOf500mm/2, y_range * scale - 10);

  ctx2d.stroke();

}

//
// ミニ四駆の位置をXYで再プロットする
//
function updateEstimatedMachinePosition()
{
  drawEstimatedMachinePosition(document.getElementById("canvas_graph_xy_plot"), TracingContext.xArr, TracingContext.yArr, TracingContext.lapArr);
}


//
// 観測された回転半径の頻度を表す棒グラフを描画
//
function drawFeatureDistributionGraph(canvas_name, arr, x, y, label, min_range, max_range, step, threshold)
{
  var canvas = document.getElementById(canvas_name);

  var width = arr.length * 4;
  var height = 300;
  var scale = Math.max(...arr);

  var margin_x = 50;
  var margin_y = 100;

  canvas.setAttribute("width",  width + margin_x *2);
  canvas.setAttribute("height", height + margin_y);

  var ctx2d = canvas.getContext("2d");

  _drawGraph(GraphTypeBar, ctx2d, arr, x + margin_x, y + margin_y/2, width, height, step, 0, min_range, max_range, label)

//  drawBarGraphRuledLine(ctx2d, x + margin_x, y + margin_y/2, width, height, margin_y/2, label, min_range, max_range, step);
//  drawBarGraphBody(ctx2d, arr, x + margin_x, y + margin_y/2, width, height);

  //J リファレンスとなる中央、外周、内周の半径をプロットする
  var bin_width = 2;
  var bin_center = width * (Jcjc_CenterRadius-min_range) /(max_range - min_range)
  var bin_outer =  width * (Jcjc_OuterRadius -min_range) /(max_range - min_range)
  var bin_inner =  width * (Jcjc_InnerRadius -min_range) /(max_range - min_range)

  ctx2d.fillStyle = "blue";
  ctx2d.fillRect(x + margin_x + bin_center - bin_width/2,  y + margin_y/2, bin_width, height);
  ctx2d.fillRect(x + margin_x + bin_outer  - bin_width/2,  y + margin_y/2, bin_width, height);
  ctx2d.fillRect(x + margin_x + bin_inner  - bin_width/2,  y + margin_y/2, bin_width, height);

  ctx2d.beginPath();
  ctx2d.textAlign="center";
  ctx2d.strokeText("L/Center", x + margin_x + bin_center - bin_width/2, y + margin_y/3);
  ctx2d.strokeText("L/Outer",  x + margin_x + bin_outer  - bin_width/2, y + margin_y/3);
  ctx2d.strokeText("L/Inner",  x + margin_x + bin_inner  - bin_width/2, y + margin_y/3);
  ctx2d.stroke();

  bin_center = width * (-Jcjc_CenterRadius-min_range) /(max_range - min_range)
  bin_outer =  width * (-Jcjc_OuterRadius -min_range) /(max_range - min_range)
  bin_inner =  width * (-Jcjc_InnerRadius -min_range) /(max_range - min_range)

  ctx2d.fillStyle = "green";
  ctx2d.fillRect(x + margin_x + bin_center - bin_width/2,  y + margin_y/2, bin_width, height);
  ctx2d.fillRect(x + margin_x + bin_outer  - bin_width/2,  y + margin_y/2, bin_width, height);
  ctx2d.fillRect(x + margin_x + bin_inner  - bin_width/2,  y + margin_y/2, bin_width, height);

  ctx2d.beginPath();
  ctx2d.textAlign="center";
  ctx2d.strokeText("R/Center", x + margin_x + bin_center - bin_width/2, y + margin_y/3);
  ctx2d.strokeText("R/Outer",  x + margin_x + bin_outer  - bin_width/2, y + margin_y/3);
  ctx2d.strokeText("R/Inner",  x + margin_x + bin_inner  - bin_width/2, y + margin_y/3);
  ctx2d.stroke();

  //J 閾値を破線でプロットする
  segs = ctx2d.getLineDash()
  ctx2d.lineWidth = 2;
  ctx2d.setLineDash([6,3]);

  //J 左カーブ
  ctx2d.strokeStyle = "midnightblue"
  ctx2d.beginPath();

  bin_threshold = width * (threshold.inter_to_center_left - min_range) /(max_range - min_range)
  ctx2d.moveTo(x + margin_x + bin_threshold - bin_width/2,  y + margin_y/2);
  ctx2d.lineTo(x + margin_x + bin_threshold - bin_width/2,  y + margin_y/2 + height);

  bin_threshold = width * (threshold.center_to_outer_left - min_range) /(max_range - min_range)
  ctx2d.moveTo(x + margin_x + bin_threshold - bin_width/2,  y + margin_y/2);
  ctx2d.lineTo(x + margin_x + bin_threshold - bin_width/2,  y + margin_y/2 + height);

  ctx2d.stroke();

  //J 右カーブ
  ctx2d.strokeStyle = "darkslategray"
  ctx2d.beginPath();

  bin_threshold = width * (threshold.inter_to_center_right - min_range) /(max_range - min_range)
  ctx2d.moveTo(x + margin_x + bin_threshold - bin_width/2,  y + margin_y/2);
  ctx2d.lineTo(x + margin_x + bin_threshold - bin_width/2,  y + margin_y/2 + height);

  bin_threshold = width * (threshold.center_to_outer_right - min_range) /(max_range - min_range)
  ctx2d.moveTo(x + margin_x + bin_threshold - bin_width/2,  y + margin_y/2);
  ctx2d.lineTo(x + margin_x + bin_threshold - bin_width/2,  y + margin_y/2 + height);

  ctx2d.stroke();

  ctx2d.setLineDash(segs)
}

//
// 状態空間を描画するのに必要なサイズをmm単位で取得します
//
function checkRectSize(vec)
{
  var w, h;
  var min_x = 0;
  var max_x = 0;
  var min_y = 0;
  var max_y = 0;

  for (var i=0 ; i<vec.length ; ++i) {
    if (vec[i].x > max_x) {
      max_x = vec[i].x;
    }
    if (vec[i].x < min_x) {
      min_x = vec[i].x;
    }

    if (vec[i].y > max_y) {
      max_y = vec[i].y;
    }
    if (vec[i].y < min_y) {
      min_y = vec[i].y;
    }
  }

  return new RectSize(max_x-min_x, max_y-min_y);
}

//
// キャンパス(w x h)内で、原点位置になる場所を求めます
//
function originInCanvas2d(w, h, vec)
{
  var min_x = 0;
  var max_x = 0;
  var min_y = 0;
  var max_y = 0;

  for (var i=0 ; i<vec.length ; ++i) {
    if (vec[i].x > max_x) {
      max_x = vec[i].x;
    }
    if (vec[i].x < min_x) {
      min_x = vec[i].x;
    }

    if (vec[i].y > max_y) {
      max_y = vec[i].y;
    }
    if (vec[i].y < min_y) {
      min_y = vec[i].y;
    }
  }

  var scale = w / (max_x - min_x);

  return new Position(Math.round(scale * -min_x), Math.round(scale * -min_y));
}

//
// 状態空間の描画
//
function drawStateSpaceVector(canvas_name, vec, position)
{
  var AlphaMap = ["ff", "ff", "ff"];
  if (0 <= position && position < vec.length) {
    var highlite_lap = vec[position].lap;

    AlphaMap = ["20", "20", "20"];
    AlphaMap[highlite_lap] = "ff";
  }

  //J mapのサイズを取得する
  var map_size = checkRectSize(vec);

  //J 様々な情報を描画するのに使うエリアをとっておく
  var margin_x = 50;
  var margin_y = 100;

  //J キャンパスのサイズを決定
  var scale = (document.getElementById("sensor_visualizer").clientWidth - margin_x) / map_size.w;
  var canvas = document.getElementById(canvas_name);
  var canvas_size = new RectSize(map_size.w * scale + margin_x, map_size.h * scale + margin_y);
  canvas.setAttribute("width",  (map_size.w * scale + margin_x).toString(10));
  canvas.setAttribute("height", (map_size.h * scale + margin_y).toString(10));

  //J キャンパス内での原点(0, 0) を決める
  var org = originInCanvas2d((map_size.w * scale), (map_size.h * scale), vec);
  org.x += margin_x/2;
  org.y += margin_y/2;

  var ctx2d = canvas.getContext("2d");
  ctx2d.fillStyle = "rgba(0, 0, 0, 0)";
  ctx2d.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);

  ctx2d.lineWidth = 1.5
  for (var i=0; i<vec.length ; ++i) {
    if (document.lane_select.lanes[vec[i].lap].checked == false) {
      continue;
    }

    ctx2d.beginPath()
    ctx2d.strokeStyle = FeatureColorTable[vec[i].feature] + AlphaMap[vec[i].lap];
    ctx2d.fillStyle = (i == position) ? "#ff1493ff" : "#00000000"; //TODO
    ctx2d.arc(vec[i].x * scale + org.x, canvas_size.h - (vec[i].y * scale + org.y), 10, 0, Math.PI*2, false);
    ctx2d.fill();
    ctx2d.stroke();
  }

  //J 尺のリファレンスを置く
  var sizeOf500mm = scale * 500;
  ctx2d.lineWidth = 1;
  ctx2d.strokeStyle = "#000000"
  ctx2d.beginPath();
  ctx2d.moveTo(canvas_size.w - 20, canvas_size.h - 20);
  ctx2d.lineTo(canvas_size.w - 20 - sizeOf500mm, canvas_size.h - 20);

  ctx2d.moveTo(canvas_size.w - 20 - sizeOf500mm, canvas_size.h - 10);
  ctx2d.lineTo(canvas_size.w - 20 - sizeOf500mm, canvas_size.h - 30);

  ctx2d.moveTo(canvas_size.w - 20, canvas_size.h - 10);
  ctx2d.lineTo(canvas_size.w - 20, canvas_size.h - 30);

  ctx2d.textAlign="center";
  ctx2d.strokeText("500mm", canvas_size.w - 20 - sizeOf500mm/2, canvas_size.h - 10);

  ctx2d.stroke();

  return;
}

function drawExistanceGraph(canvas_name, arr)
{
  var canvas = document.getElementById(canvas_name);

  var width = arr.length;
  var height = 300;

  var margin_x = 0;
  var margin_y = 50;

  if (width > document.getElementById("panel5").clientWidth) {
    margin_x = 50;
  }
  else {
    margin_x = (document.getElementById("panel5").clientWidth - width)/2;
  }


  canvas.setAttribute("width",  width + margin_x *2);
  canvas.setAttribute("height", height + margin_y);

  var ctx2d = canvas.getContext("2d");

  _drawGraph(GraphTypeLine, ctx2d, arr, margin_x, 0, width, height, 100, 0, 0, Math.max(...arr), "Existance");
}



//
// 特徴量マップの再描画
//
function updateStateSpaceVector()
{
  drawStateSpaceVector("canvas_graph_estimate_position", StateSpaceVec, -1);
}

/*-------------------------------------------------------------------------------------------------
 * HTML Form まわりの挙動を記載
 */
//
// SELECTボタンが押されたときの挙動
//
function onFileLoadButtonClick()
{
  document.getElementById("sensor_file").click();
  document.getElementById("sensor_file").addEventListener('change', handleSensorFileSelect, false);
}

//
//
//
function onTestFileLoadButtonClick()
{
  document.getElementById("test_sensor_file").click();
  document.getElementById("test_sensor_file").addEventListener('change', handleTestSensorFileSelect, false);
}


//
// File Selecterがクリックされたときの挙動
//
function handleSensorFileSelect(evt)
{
  var file = evt.target.files[0];

  //J ファイル名の表示
  sensor_file_name.innerHTML = file.name;

  //J ファイルの内容をパースする
  loadAndParseSensorFile(file);
}

//
// Test File Selecterがクリックされたときの挙動
//
function handleTestSensorFileSelect(evt)
{
  var file = evt.target.files[0];

  //J ファイル名の表示
  test_sensor_file_name.innerHTML = file.name;

  //J ファイルの内容をパースする
 loadAndParseSensorFileForTest(file);
}

//
// ホイールの選択（プルダウンセレクト）が変更になった際の処理
//
function onWheelSelected()
{
  document.getElementById("wheel_size").value = document.getElementById("wheel_select").options[document.getElementById("wheel_select").selectedIndex].value;

  updateVelocityAndOdometryGraph();
}

//
// ホイールサイズが直接入力されたとき
//
function onWheelSizeChanged()
{
  updateVelocityAndOdometryGraph();
}

//
// 一定時間ごとに実行されるシミュレータの処理
//
function onSimulaterTimerEvent()
{
  if (TestData[0].length == 0) {
    return;
  }

  var val = document.getElementById("map_range").value;
  val++;
  if (val < document.getElementById("map_range").max) {
    updateSimulater(val);

    document.getElementById("map_range").value = val;
  }
}

//
// 推定スタートボタン
//
var TimerId = NaN;
function onStartButtonClick()
{
  if (TestData[0].length == 0) {
    return;
  }

  if (isNaN(TimerId)) {
    TimerId = setInterval(onSimulaterTimerEvent, 1000/52);
  }
  else {
    clearInterval(TimerId);
    TimerId = NaN
  }
}

//
// 推定リセットボタン
//
function onResetButtonClick()
{
  SelfPositionEstimater.initialize();
}

//
// カーブの補正係数のUpdate
//
function onCoeffUndated()
{
  document.getElementById("rightCoeffValue").innerHTML = document.getElementById("rightCoeff").value.toString();
  document.getElementById("leftCoeffValue").innerHTML  = document.getElementById("leftCoeff").value.toString();

  var coeff = {
    right : document.getElementById("rightCoeff").value,
    left  : document.getElementById("leftCoeff").value
  }

  estimateMachinePosition(SensorData, coeff);
  drawEstimatedMachinePosition(document.getElementById("canvas_graph_xy_plot"), TracingContext.xArr, TracingContext.yArr, TracingContext.lapArr);

  StateSpaceVec = createStateSpaceVector(SensorData, UNIT_mm, coeff, ThresholdOfCurve);
  drawStateSpaceVector("canvas_graph_estimate_position", StateSpaceVec, -1);

  dumpStateSpaceVector(StateSpaceVec);
}

//
// マップ情報を出力
//
function dumpStateSpaceVector(ssvec)
{
  var map_str = "arr_map = [" + ssvec[0].feature.toString();

  var i=0;
  for(i=1 ; i<ssvec.length ; ++i) {
    map_str += "," +  ssvec[i].feature.toString();
  }
  map_str += "]"

  document.getElementById("map_text").value = map_str;
}



</script>

</HEAD>
<BODY>
<div class="header_menu">
  <div class="dash_board">
    <div class="menu_title"> <font class="logo_outline">AI mini4wd Kit</font></div>
  </div>
</div>
<div class="top" id="top"></div>

<div class = "wrapper">
<div class="tab_wrap">

</div>


<div class = "map_canvas" id = "sensor_visualizer">
  <div class = "sub_section">Visualize Sensor Data</div>
  <div class = "button_left">
    <span class="buttons">
      <a href="#" onclick="onFileLoadButtonClick();"  class="control_btn">Learning Data</a>
      <text id="sensor_file_name">File not selected</text>
    </span>
    <span class="buttons">
      <a href="#" onclick="onTestFileLoadButtonClick();"  class="control_btn">Test Data</a>
      <text id="test_sensor_file_name">File not selected</text>
    </span>
  </div>
  <input hidden type="file" id="sensor_file" />
  <input hidden type="file" id="test_sensor_file" />
  <div class="wheel_select">
  Select the wheel size: 
  <select id="wheel_select" onChange="onWheelSelected()">
    <option value="31">大径ホイール</option>
    <option value="26">中径ホイール</option>
    <option value="24">小径ホイール</option>
    <option value="31">カスタムホイール</option>
  </select>
  <input type="number" id="wheel_size" size="4" maxlength="5" value="31" onChange="onWheelSizeChanged()">[mm]
  </div>
  <!-- 正直これが美しいやり方なのかどうかについては自信がない -->
  <input class="for_tabs" id="tab1" type="radio" name="tab_btn" checked>
  <input class="for_tabs" id="tab2" type="radio" name="tab_btn">
  <input class="for_tabs" id="tab3" type="radio" name="tab_btn">
  <input class="for_tabs" id="tab4" type="radio" name="tab_btn">
  <input class="for_tabs" id="tab5" type="radio" name="tab_btn">

  <div class="tab_labels">
    <label class="tab1_label" for="tab1">Raw Data</label>
    <label class="tab2_label" for="tab2">Velocity/Odometry</label>
    <label class="tab3_label" for="tab3">X-Y Plot</label>
    <label class="tab4_label" for="tab4">Re-sampling</label>
    <label class="tab5_label" for="tab5">Estimate Position</label>
  </div>
  <div class="tab_contents">
    <div id="panel1" class="tab_content">
      <div class = "canvas_graph">
        <form name="data_select_form">
          <span class="check_box_span"><input type="checkbox" name="sensors" value="ax" checked ="1" onChange="updateRawDataGraph()">X軸加速度[mg]</span>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="ay" checked ="1" onChange="updateRawDataGraph()">Y軸加速度[mg]</span>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="az" checked ="1" onChange="updateRawDataGraph()">Z軸加速度[mg]</span>
          <br>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="pitch" checked ="1" onChange="updateRawDataGraph()">pitch[mdegree/sec]</span>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="roll" checked ="1" onChange="updateRawDataGraph()">roll[mdegree/sec]</span>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="yaw" checked ="1" onChange="updateRawDataGraph()">yaw[mdegree/sec]</span>
          <br>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="rpm" checked ="1" onChange="updateRawDataGraph()">車軸回転数[rpm]</span>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="vbat" checked ="1" onChange="updateRawDataGraph()">バッテリ電圧[mV]</span>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="imon" checked ="1" onChange="updateRawDataGraph()">モーター電流[mA]</span>
        </form>
        X軸補助線は5秒毎
        <canvas id="canvas_graph_raw" width="100%" height="0pt"></canvas><br>
      </div>
    </div>
    <div id="panel2" class="tab_content">
      <div class = "canvas_graph">
        <canvas id="canvas_graph_velocity" width="100%" height="0pt"></canvas><br>
      </div>
    </div>
    <div id="panel3" class="tab_content">
      <div class = "canvas_graph">
        <div class = "lap_selecter" id="lap_selecter">
        </div>
        Right Turn Coeff<br><input type="range" id="rightCoeff" value="1"  min="0" max="2" step="0.01" oninput="onCoeffUndated()"><span id="rightCoeffValue">1</span><br>
        Left  Turn Coeff<br><input type="range" id="leftCoeff"  value="1"  min="0" max="2" step="0.01" oninput="onCoeffUndated()"><span id="leftCoeffValue">1</span><br>
        <canvas id="canvas_graph_xy_plot" width="100%" height="0pt"></canvas><br>
      </div>
    </div>
    <div id="panel4" class="tab_content">
      <div class = "canvas_graph">
        50mm単位で再サンプリングします。加速度、回転数、バッテリ電圧、モーター電流は平均、角速度は積分します。X軸補助線は1mを表します。
        <form name="resampled_data_select_form">
          <span class="check_box_span"><input type="checkbox" name="sensors" value="ax" checked ="1" onChange="updateResampledDataGraph()">X軸加速度[mg]</span>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="ay" checked ="1" onChange="updateResampledDataGraph()">Y軸加速度[mg]</span>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="az" checked ="1" onChange="updateResampledDataGraph()">Z軸加速度[mg]</span>
          <br>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="pitch" checked ="1" onChange="updateResampledDataGraph()">pitch[mdegree/sec]</span>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="roll" checked ="1" onChange="updateResampledDataGraph()">roll[mdegree/sec]</span>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="yaw" checked ="1" onChange="updateResampledDataGraph()">yaw[mdegree/sec]</span>
          <br>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="rpm" checked ="1" onChange="updateResampledDataGraph()">車軸回転数[rpm]</span>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="vbat" checked ="1" onChange="updateResampledDataGraph()">バッテリ電圧[mV]</span>
          <span class="check_box_span"><input type="checkbox" name="sensors" value="imon" checked ="1" onChange="updateResampledDataGraph()">モーター電流[mA]</span>
        </form>
        <canvas id="canvas_graph_resampling" width="100%" height="0pt"></canvas><br>
        <br>
        センサデータから得られたマシンの回転半径のヒストグラムです。青線（3本）がJCJCのコーナーパーツのサイズから得られるコース中央の左回転半径
        緑線（3本）が右回転半径です。
        <canvas id="canvas_graph_feature" width="100%" height="0pt"></canvas><br>
      </div>
    </div>
    <div id="panel5" class="tab_content">
      <div class = "canvas_graph">
        <form name="lane_select">
          <span><input type="checkbox" name="lanes" value="lane1" checked ="1" onChange="updateStateSpaceVector()">Lane 1</span>
          <span><input type="checkbox" name="lanes" value="lane2" checked ="1" onChange="updateStateSpaceVector()">Lane 2</span>
          <span><input type="checkbox" name="lanes" value="lane3" checked ="1" onChange="updateStateSpaceVector()">Lane 3</span>
        </form>
        <a href="#" onclick="onStartButtonClick();"  class="control_btn">START</a>
        <a href="#" onclick="onResetButtonClick();"  class="control_btn">RESET</a>
        <div class="map_range">
          <input type="range" id="map_range" class ="map_range" value="0" min="0" max="0" step="1" oninput="">
        </div>
        <canvas id="canvas_graph_estimate_position" width="100%" height="0pt"></canvas><br>
        <canvas id="canvas_graph_existance" width="100%" height="0pt"></canvas><br>
	推定されたマップ情報(array)
	<textarea class = "map_array" id = "map_text"></textarea>
      </div>
    </div>
  </div>


  <div class = "sub_section">Sample data</div>
  <a href="learning.txt" download="learning.txt">learning_sensor_log_data</a> <br>
  <a href="test_data.txt" download="test_data.txt">test_sensor_log_data</a> <br>
</div>

</div>
<div class="footer_menu">
<div class="menu_copy">Copyright 2019 aks3g.com All rights reserved.</div>
<div>
</BODY>
</HTML>